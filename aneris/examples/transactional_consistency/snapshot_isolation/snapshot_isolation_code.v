(* This file is automatically generated from the OCaml source file
<repository_root>/ml_sources/examples/transactional_consistency/snapshot_isolation/snapshot_isolation_code.ml *)

From aneris.aneris_lang Require Import ast.
From aneris.aneris_lang.lib Require Import list_code.
From aneris.aneris_lang.lib Require Import map_code.
From aneris.aneris_lang.lib Require Import network_util_code.
From aneris.aneris_lang.lib.serialization Require Import serialization_code.
From aneris.examples.reliable_communication.lib.mt_server Require Import mt_server_code.

(**  The internal state of the server  *)

Definition req_ser val_ser :=
  sum_serializer (prod_serializer string_serializer int_serializer)
  (sum_serializer unit_serializer
   (prod_serializer int_serializer
    (list_serializer (prod_serializer string_serializer val_ser)))).

Definition repl_ser val_ser :=
  sum_serializer (option_serializer val_ser)
  (sum_serializer (prod_serializer int_serializer
                   (list_serializer (prod_serializer int_serializer
                                     bool_serializer)))
   bool_serializer).

Definition kvs_get : val :=
  λ: "k" "kvs",
  match: map_lookup "k" "kvs" with
    NONE => []
  | SOME "vlst" => assert: (~ ("vlst" = NONE));;
                   "vlst"
  end.

Definition kvs_get_last : val :=
  λ: "kt" "kvs",
  let: "k" := Fst "kt" in
  let: "t" := Snd "kt" in
  letrec: "aux" "l" :=
    match: "l" with
      NONE => NONE
    | SOME "p" =>
        let: "_k" := Fst (Fst "p") in
        let: "v" := Fst (Snd (Fst "p")) in
        let: "tv" := Snd (Snd (Fst "p")) in
        let: "tl" := Snd "p" in
        (if: "tv" = "t"
         then  assert: #false
         else  (if: "tv" < "t"
           then  SOME "v"
           else  "aux" "tl"))
    end in
    "aux" (kvs_get "k" "kvs").

Definition update_kvs : val :=
  λ: "kvs" "cache" "tc",
  letrec: "upd" "kvs_t" "cache_t" :=
    match: "cache_t" with
      NONE => "kvs_t"
    | SOME "chl" =>
        let: "kv" := Fst "chl" in
        let: "cache_l" := Snd "chl" in
        let: "k" := Fst "kv" in
        let: "v" := Snd "kv" in
        let: "vlst" := kvs_get "k" "kvs" in
        let: "newval" := ("k", ("v", "tc")) in
        let: "newvals" := "newval" :: "vlst" in
        let: "kvs_t'" := map_insert "k" "newvals" "kvs_t" in
        "upd" "kvs_t'" "cache_l"
    end in
    "upd" "kvs" "cache".

Definition update_transaction_list : val :=
  λ: "uts" "trs",
  let: "trs_" := ! "trs" in
  let: "ts" := Fst "trs_" in
  let: "trs_list" := Snd "trs_" in
  letrec: "upd" "l" :=
    match: "l" with
      NONE => []
    | SOME "p" =>
        let: "transaction" := Fst "p" in
        let: "list" := Snd "p" in
        let: "t" := Fst "transaction" in
        let: "b" := Snd "transaction" in
        (if: "t" = "uts"
         then  ("t", #false) :: "list"
         else  ("t", "b") :: "upd" "list")
    end in
    ("ts" + #1, "upd" "trs_list").

Definition check_at_key : val :=
  λ: "ts" "tc" "vlst",
  assert: ("ts" < "tc");;
  match: "vlst" with
    NONE => #true
  | SOME "l" =>
      let: "vlast" := Fst "l" in
      let: "_hd" := Snd "l" in
      let: "_k" := Fst "vlast" in
      let: "_v" := Fst (Snd "vlast") in
      let: "t" := Snd (Snd "vlast") in
      (if: ("tc" ≤ "t") || ("t" = "ts")
       then  assert: #false
       else  "t" < "ts")
  end.

Definition find_oldest_active : val :=
  λ: "trs",
  let: "trs_" := ! "trs" in
  let: "ts" := Fst "trs_" in
  let: "trs_list" := Snd "trs_" in
  letrec: "active" "ts" "l" :=
    match: "l" with
      NONE => "ts"
    | SOME "p" =>
        let: "transaction" := Fst "p" in
        let: "list" := Snd "p" in
        let: "t" := Fst "transaction" in
        let: "b" := Snd "transaction" in
        (if: "b"
         then  "active" ((if: ("t" < "ts")
                          then  "t"
                          else  "ts")) "list"
         else  "active" "ts" "list")
    end in
    "active" "ts" "trs_list".

Definition remove_old_transactions : val :=
  λ: "active" "vlsto",
  letrec: "remove" "v" "v_new" :=
    match: "v" with
      NONE => "v_new"
    | SOME "p" =>
        let: "v" := Fst "p" in
        let: "vlist" := Snd "p" in
        let: "_k" := Fst "v" in
        let: "_v" := Fst (Snd "v") in
        let: "ts" := Snd (Snd "v") in
        (if: "ts" < "active"
         then  "v_new"
         else  "remove" "vlist" ("v" :: "v_new"))
    end in
    "remove" "vlsto" NONE.

Definition garbage_collection : val :=
  λ: "kvs" "cache" "trs",
  let: "active_ts" := find_oldest_active "trs" in
  let: "_b" := map_forall (λ: "k" "_v",
                           let: "vlsto" := map_lookup "k" ! "kvs" in
                           (if: "vlsto" = NONE
                            then  #true
                            else
                              let: "vlsto" := unSOME "vlsto" in
                              "kvs" <- (map_insert "k"
                                        (remove_old_transactions "active_ts"
                                         "vlsto")
                                        ! "kvs");;
                              #true))
               "cache" in
  ! "kvs".

Definition commit_handler : val :=
  λ: "kvs" "cdata" "trs" <>,
  let: "ts" := Fst "cdata" in
  let: "cache" := Snd "cdata" in
  "kvs" <- (garbage_collection "kvs" "cache" "trs");;
  "trs" <- (update_transaction_list "ts" "trs");;
  let: "trs_" := ! "trs" in
  let: "tc" := Fst "trs_" in
  let: "_trs_list" := Snd "trs_" in
  let: "kvs_t" := ! "kvs" in
  (if: list_is_empty "cache"
   then  #true
   else
     let: "b" := map_forall (λ: "k" "_v",
                             let: "vlsto" := map_lookup "k" "kvs_t" in
                             let: "vs" := (if: "vlsto" = NONE
                              then  []
                              else  unSOME "vlsto") in
                             check_at_key "ts" "tc" "vs")
                 "cache" in
     (if: "b"
      then  "kvs" <- (update_kvs "kvs_t" "cache" "tc");;
            #true
      else  #false)).

Definition lk_handle : val :=
  λ: "lk" "handler",
  acquire "lk";;
  let: "res" := "handler" #() in
  release "lk";;
  "res".

Definition read_handler : val :=
  λ: "kvs" "tk" <>, kvs_get_last "tk" ! "kvs".

Definition start_handler : val :=
  λ: "trs" <>,
  let: "trs_" := ! "trs" in
  let: "ts" := Fst "trs_" in
  let: "trs_l" := Snd "trs_" in
  let: "vnext" := "ts" + #1 in
  let: "trs_l_next" := ("vnext", #true) :: "trs_l" in
  "trs" <- ("vnext", "trs_l_next");;
  ! "trs".

Definition client_request_handler : val :=
  λ: "lk" "kvs" "trs" "req",
  let: "res" := match: "req" with
    InjL "tk" => InjL (lk_handle "lk" (read_handler "kvs" "tk"))
  | InjR "r" =>
      match: "r" with
        InjL "_tt" => InjR (InjL (lk_handle "lk" (start_handler "trs")))
      | InjR "cdata" =>
          InjR (InjR (lk_handle "lk" (commit_handler "kvs" "cdata" "trs")))
      end
  end in
  "res".

Definition start_server_processing_clients ser : val :=
  λ: "addr" "lk" "kvs" "trs" <>,
  run_server (repl_ser ser) (req_ser ser) "addr"
  (λ: "req", client_request_handler "lk" "kvs" "trs" "req").

Definition init_server ser : val :=
  λ: "addr",
  let: "kvs" := ref (map_empty #()) in
  let: "trs" := ref (#0, []) in
  let: "lk" := newlock #() in
  Fork (start_server_processing_clients ser "addr" "lk" "kvs" "trs" #()).

Definition init_client_proxy ser : val :=
  λ: "clt_addr" "srv_addr",
  let: "rpc" := init_client_proxy (req_ser ser) (repl_ser ser) "clt_addr"
                "srv_addr" in
  let: "txt" := ref NONE in
  let: "lk" := newlock #() in
  ("clt_addr", ("lk", ("rpc", "txt"))).

Definition start : val :=
  λ: "cst",
  let: "_clt_addr" := Fst "cst" in
  let: "lk" := Fst (Snd "cst") in
  let: "rpc" := Fst (Snd (Snd "cst")) in
  let: "tst" := Snd (Snd (Snd "cst")) in
  acquire "lk";;
  match: ! "tst" with
    SOME "_abs" => assert: #false
  | NONE =>
      let: "repl" := make_request "rpc" (InjR (InjL #())) in
      match: "repl" with
        InjL "_abs" => assert: #false
      | InjR "s" =>
          match: "s" with
            InjL "trs" =>
            let: "ts" := Fst "trs" in
            let: "_trs_list" := Snd "trs" in
            "tst" <- (SOME ("ts", (ref (map_empty #()))))
          | InjR "_abs" => assert: #false
          end
      end
  end;;
  release "lk".

Definition read : val :=
  λ: "cst" "k",
  let: "_clt_addr" := Fst "cst" in
  let: "lk" := Fst (Snd "cst") in
  let: "rpc" := Fst (Snd (Snd "cst")) in
  let: "tst" := Snd (Snd (Snd "cst")) in
  acquire "lk";;
  let: "vo" := match: ! "tst" with
    NONE => assert: #false
  | SOME "st" =>
      let: "ts" := Fst "st" in
      let: "cache" := Snd "st" in
      match: map_lookup "k" ! "cache" with
        SOME "v" => SOME "v"
      | NONE =>
          let: "repl" := make_request "rpc" (InjL ("k", "ts")) in
          match: "repl" with
            InjL "vo" => "vo"
          | InjR "_abs" => assert: #false
          end
      end
  end in
  release "lk";;
  "vo".

Definition write : val :=
  λ: "cst" "k" "v",
  let: "_clt_addr" := Fst "cst" in
  let: "lk" := Fst (Snd "cst") in
  let: "_rpc" := Fst (Snd (Snd "cst")) in
  let: "tst" := Snd (Snd (Snd "cst")) in
  acquire "lk";;
  match: ! "tst" with
    NONE => assert: #false
  | SOME "st" =>
      let: "_ts" := Fst "st" in
      let: "cache" := Snd "st" in
      "cache" <- (map_insert "k" "v" ! "cache");;
      release "lk"
  end.

Definition commit : val :=
  λ: "cst",
  let: "_clt_addr" := Fst "cst" in
  let: "lk" := Fst (Snd "cst") in
  let: "rpc" := Fst (Snd (Snd "cst")) in
  let: "tst" := Snd (Snd (Snd "cst")) in
  acquire "lk";;
  let: "b" := match: ! "tst" with
    NONE => assert: #false
  | SOME "st" =>
      let: "ts" := Fst "st" in
      let: "cache" := Snd "st" in
      let: "repl" := let: "cch" := ! "cache" in
                     (if: "cch" = NONE
                      then  InjR (InjR #true)
                      else  make_request "rpc" (InjR (InjR ("ts", "cch")))) in
      match: "repl" with
        InjL "_abs" => assert: #false
      | InjR "r" =>
          match: "r" with
            InjL "_abs" => assert: #false
          | InjR "b" => "tst" <- NONE;;
                        "b"
          end
      end
  end in
  release "lk";;
  "b".
