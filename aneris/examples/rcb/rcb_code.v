(* This file is automatically generated from the OCaml source file
<repository_root>/ml_sources/rcb/rcb_code.ml *)

From aneris.aneris_lang Require Import ast.
From aneris.aneris_lang.lib Require Import list_code.
From aneris.aneris_lang.lib Require Import queue_code.
From aneris.aneris_lang.lib Require Import network_util_code.
From aneris.aneris_lang.lib.vector_clock Require Import vector_clock_code.
From aneris.aneris_lang.lib.serialization Require Import serialization_code.

Definition rep_id_ser := int_ser.

Definition rep_id_deser := int_deser.

Definition seqnum_ser := int_ser.

Definition seqnum_deser := int_deser.

Definition ack_msg_ser :=
  prod_ser (prod_ser rep_id_ser seqnum_ser) rep_id_ser.

Definition ack_msg_deser :=
  prod_deser (prod_deser rep_id_deser seqnum_deser) rep_id_deser.

Definition broadcast_msg_ser val_ser :=
  prod_ser (prod_ser (prod_ser val_ser vect_serialize) rep_id_ser) rep_id_ser.

Definition broadcast_msg_deser val_deser :=
  prod_deser (prod_deser (prod_deser val_deser vect_deserialize) rep_id_deser)
  rep_id_deser.

Definition msg_ser val_ser :=
  sum_ser ack_msg_ser (broadcast_msg_ser val_ser).

Definition msg_deser val_deser :=
  sum_deser ack_msg_deser (broadcast_msg_deser val_deser).

Definition loop_forever : val :=
  rec: "loop_forever" "thunk" := "thunk" #();;
                                 "loop_forever" "thunk".

Definition send_thread val_ser : val :=
  λ: "i" "socket_handler" "lock" "nodes" "outQueues",
  let: "send_head" := λ: "j" "q",
  match: queue_peek_opt "q" with
    SOME "msg" =>
    let: "dest" := unSOME (list_nth "nodes" "j") in
    SendTo "socket_handler" (msg_ser val_ser (InjR ("msg", "i"))) "dest";;
    #()
  | NONE => #()
  end in
  loop_forever (λ: <>,
                acquire "lock";;
                list_iteri "send_head" ! "outQueues";;
                release "lock").

Definition send_ack val_ser : val :=
  λ: "socket_handler" "origId" "sn" "senderId" "dest_addr",
  let: "ack" := InjL ("origId", "sn", "senderId") in
  let: "ack_raw" := msg_ser val_ser "ack" in
  SendTo "socket_handler" "ack_raw" "dest_addr";;
  #().

Definition prune_ack : val :=
  λ: "origId" "sn" "q",
  match: queue_peek_opt "q" with
    SOME "e" =>
    let: "_p" := Fst (Fst "e") in
    let: "vc" := Snd (Fst "e") in
    let: "origMsg" := Snd "e" in
    let: "snMsg" := vect_nth "vc" "origId" in
    (if: ("origMsg" = "origId") && ("snMsg" = "sn")
     then
       let: "x" := unSOME (queue_take_opt "q") in
       let: "_e" := Fst "x" in
       let: "rest" := Snd "x" in
       "rest"
     else  "q")
  | NONE => "q"
  end.

Definition recv_thread val_ser val_deser : val :=
  λ: "i" "socket_handler" "lock" "addrlst" "inQueue" "outQueues" "seen",
  let: "receive" := λ: "msg",
  match: "msg" with
    InjL "ackMsg" =>
    let: "origId" := Fst (Fst "ackMsg") in
    let: "sn" := Snd (Fst "ackMsg") in
    let: "senderId" := Snd "ackMsg" in
    let: "senderQ" := unSOME (list_nth ! "outQueues" "senderId") in
    let: "senderQ'" := prune_ack "origId" "sn" "senderQ" in
    "outQueues" <- (list_update ! "outQueues" "senderId" "senderQ'")
  | InjR "bcstMsg" =>
      let: "payload" := Fst (Fst (Fst "bcstMsg")) in
      let: "vc" := Snd (Fst (Fst "bcstMsg")) in
      let: "origId" := Snd (Fst "bcstMsg") in
      let: "senderId" := Snd "bcstMsg" in
      let: "origSn" := vect_nth "vc" "origId" in
      let: "senderAddr" := unSOME (list_nth "addrlst" "senderId") in
      send_ack val_ser "socket_handler" "origId" "origSn" "i" "senderAddr";;
      let: "seenSn" := vect_nth ! "seen" "origId" in
      (if: "seenSn" < "origSn"
       then
         "seen" <- (vect_update ! "seen" "origId" "origSn");;
         "inQueue" <- (("payload", "vc", "origId") :: ! "inQueue");;
         "outQueues" <- (list_mapi (λ: "j" "q",
                                    (if: ("j" ≠ "i") && (("j" ≠ "senderId") && 
                                                           ("j" ≠ "origId"))
                                     then
                                       queue_add ("payload", "vc", "origId")
                                       "q"
                                     else  "q"))
                         ! "outQueues")
       else  #())
  end in
  loop_forever (λ: <>,
                let: "msg_raw" := Fst (unSOME (ReceiveFrom "socket_handler")) in
                let: "msg" := msg_deser val_deser "msg_raw" in
                acquire "lock";;
                "receive" "msg";;
                release "lock").

Definition is_causally_next : val :=
  λ: "vc" "my_rid",
  let: "l" := list_length "vc" in
  λ: "ev",
  let: "_payload" := Fst (Fst "ev") in
  let: "ev_vc" := Snd (Fst "ev") in
  let: "orig" := Snd "ev" in
  (if: "my_rid" = "orig"
   then  #false
   else
     (if: "orig" < "l"
     then  vect_applicable "ev_vc" "vc" "orig"
     else  #false)).

Definition deliver : val :=
  λ: "vc" "lock" "inQueue" "rid" <>,
  acquire "lock";;
  let: "remRes" := list_find_remove (is_causally_next ! "vc" "rid")
                   ! "inQueue" in
  let: "res" := match: "remRes" with
    SOME "p" =>
    let: "elem" := Fst "p" in
    let: "rest" := Snd "p" in
    let: "payload" := Fst (Fst "elem") in
    let: "msgVc" := Snd (Fst "elem") in
    let: "orig" := Snd "elem" in
    "inQueue" <- "rest";;
    "vc" <- (vect_inc ! "vc" "orig");;
    SOME ("payload", "msgVc", "orig")
  | NONE => NONE
  end in
  release "lock";;
  "res".

Definition broadcast : val :=
  λ: "vc" "seen" "outQueues" "lock" "rid" "payload",
  acquire "lock";;
  "vc" <- (vect_inc ! "vc" "rid");;
  let: "msg" := ("payload", ! "vc", "rid") in
  let: "sn" := vect_nth ! "vc" "rid" in
  "seen" <- (vect_update ! "seen" "rid" "sn");;
  "outQueues" <- (list_mapi (λ: "j" "q",
                             (if: "j" ≠ "rid"
                              then  queue_add "msg" "q"
                              else  "q"))
                  ! "outQueues");;
  release "lock";;
  "msg".

Definition rcb_init val_ser val_deser : val :=
  λ: "addrlst" "i",
  let: "n" := list_length "addrlst" in
  let: "vc" := ref (vect_make "n" #0) in
  let: "seen" := ref (vect_make "n" #0) in
  let: "inQueue" := ref [] in
  let: "outQueues" := ref (list_make "n" (queue_empty #())) in
  let: "lock" := newlock #() in
  let: "socket_handler" := NewSocket #PF_INET #SOCK_DGRAM #IPPROTO_UDP in
  let: "addr" := unSOME (list_nth "addrlst" "i") in
  SocketBind "socket_handler" "addr";;
  Fork (send_thread val_ser "i" "socket_handler" "lock" "addrlst" "outQueues");;
  Fork (recv_thread val_ser val_deser "i" "socket_handler" "lock" "addrlst"
        "inQueue" "outQueues" "seen");;
  (deliver "vc" "lock" "inQueue" "i", broadcast "vc" "seen" "outQueues"
                                      "lock" "i").
